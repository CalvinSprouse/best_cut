# imports
import json
import timeit
from itertools import combinations_with_replacement
from random import choice

from rich import print

from CuttingInput import cut_boards_requirements, raw_board_length, blade_length

# start timer for benchmarking
timer_start = timeit.default_timer()

# define the maximum number of boards each raw board can support
minimum_board_length = min([_[0] for _ in cut_boards_requirements])
maximum_supported_cuts = int(raw_board_length/minimum_board_length)

print(f"Analyzing: Raw Length={raw_board_length}, Required Boards={cut_boards_requirements}")
print(f"maximum_supported_cuts = {maximum_supported_cuts} using {minimum_board_length} as minimum length")

# find every viable method to cut the raw board into cut boards
cut_possibilities = list(combinations_with_replacement(list(range(len(cut_boards_requirements) + 1)), maximum_supported_cuts))

# print(f"There exist {len(cut_possibilities)} potential cuts. Example: {choice(cut_possibilities)}")

# determine the waste generated by each cut possibility
# while doing this remove cut configs that are too long
# cut possibilities analyzed
# [(cut_arrangement), ((number of board n cuts)), (blade waste), (raw waste), (total waste)]
cut_possibilities_analyzed = []
for cut_config in cut_possibilities:
    # create an empty array of cuts
    number_of_board_n_cuts = [0]*len(cut_boards_requirements)

    # iterate over each cut and count each type of board
    # also count the number of cuts
    cut_count = 0
    total_length_used = 0
    for cut in cut_config:
        # skip "no" cuts
        if cut == 0: continue

        # add to cut counts
        cut_count += 1

        # add to the number of boards tracker
        number_of_board_n_cuts[cut-1] += 1

        # add to the total length
        total_length_used += cut_boards_requirements[cut-1][0]

    # calculate waste
    blade_waste = blade_length * (cut_count - 1)
    raw_waste = raw_board_length - total_length_used
    total_waste = blade_waste + raw_waste

    # if the total length used exceeeds the raw baords skip
    # account for blade waste
    if total_length_used + blade_waste > raw_board_length: continue

    # remove the annoying no cuts case
    if blade_waste < 0: continue

    # append this analyzed configuration to the list
    cut_possibilities_analyzed.append([
        cut_config,
        number_of_board_n_cuts,
        blade_waste,
        raw_waste,
        total_waste
    ])

print(f"There exist {len(cut_possibilities_analyzed)} possible cuts. Example: {choice(cut_possibilities_analyzed)}.")

# sort list by least waste
cut_possibilities_analyzed.sort(key = lambda cut_list: cut_list[4])
print(f"The most efficient cut method (min={min([_[4] for _ in cut_possibilities_analyzed])}) is {cut_possibilities_analyzed[0]}.")

# cut order list (the answer) [times to be done, cut possibility]
cut_order_list = []

# determine how many of each cut possibility to use
current_cut_board_list = [_[1] for _ in cut_boards_requirements]
for cut_possibility in cut_possibilities_analyzed:
    # determine which board is going to be depleted fastest and by what factor
    min_cut_factor = max(current_cut_board_list)
    min_cut_factor_index = 0
    for index, cut_combo in enumerate(zip(cut_possibility[1], current_cut_board_list)):
        cut = cut_combo[0]
        count = cut_combo[1]
        if cut == 0: continue

        # determine how many times this cut type can be repeated for this board
        cut_factor = int(count/cut)
        if cut_factor < min_cut_factor:
            min_cut_factor_index = index
            min_cut_factor = cut_factor

    # this layout can be used min_cut_factor times
    # check this then add it to the cut order list
    # check that none of the cuts will be done too many times
    cut_works = True
    for cut, count in zip(cut_possibility[1], current_cut_board_list):
        if count - (cut * min_cut_factor) < 0:
            cut_works = False
            break

    # if the cut doesnt work skip it
    if not cut_works or min_cut_factor == 0: continue

    # subtract the values since it works
    for i in range(len(current_cut_board_list)):
        current_cut_board_list[i] -= cut_possibility[1][i] * min_cut_factor

    # append the cut
    cut_order_append = [min_cut_factor] + cut_possibility
    cut_order_list.append(cut_order_append)

# analyze the order list
total_blade_waste = sum([_[3] for _ in cut_order_list])
total_raw_waste = sum([_[4] for _ in cut_order_list])
total_waste = sum([_[5] for _ in cut_order_list])
final_cuts = [(_[0], _[2]) for _ in cut_order_list]
final_cuts.sort(key = lambda cut_list: cut_list[0])
final_cuts.reverse()
raw_boards_required = sum([_[0] for _ in cut_order_list])
total_cut_board_counts = [cut_boards_requirements[_][1] - current_cut_board_list[_] for _ in range(len(cut_boards_requirements))]

# stop timer
timer_stop = timeit.default_timer()

# print cut order
print(f"\nWaste Analysis: Blade: {total_blade_waste}, Raw: {total_raw_waste}, Total: {total_waste}")
print(f"Raw {raw_board_length} Length Boards Required: {raw_boards_required}")
print(f"Quantity Made: {total_cut_board_counts}")
print(f"Board Lengths: {[_[0] for _ in cut_boards_requirements]}")
print(f"Cuts Required:")
for cut in final_cuts: print(f"{cut[0]} Times: {cut[1]}")
print(f"\nElapsed Time: {timer_stop - timer_start} seconds")